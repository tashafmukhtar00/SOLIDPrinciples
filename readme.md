# SOLID Principles

## SOLID is an acronym that stands for five key design principles:

    1. Single Responsibility Principle (SRP)

    2. Open-Closed Principle (OCP)

    3. Liskov Substitution Principle (LSP)

    4. Interface Segregation Principle (ISP)

    5. Dependency Inversion Principle (DIP) 

###### All five are commonly used by software engineers and provide some important benefits for developers.

## Advantages of SOLID Principles
    Achieve the reduction in complexity of the code
    Increase readability, extensibility, and maintenance
    Increase scalability, code flexibility, and readability
    Achieve Better testability
    Reduce tight coupling
    Reduce error and implement Reusability
    Increase Parallel development*/

## Single Responsibility Principle (SRP)

    The Single Responsibility Principle states, "Each software module or class should have only one
    reason to changeâ€œ. In other words, we can say that each module or class should have only one
    responsibility to do.

## Open-Closed Principle (OCP)

    The Open/Closed Principle is one of the SOLID principles of software design, which suggests that
    software entities such as classes, modules, and functions should be open for extension but closed for
    modification. This principle states that you should be able to add new functionality to a system
    without having to modify existing code.

## Liskov Substitution Principle (LSP)

    The Liskov Substitution Principle (LSP) is a principle in object-oriented programming that states that
    objects of a superclass should be replaceable with objects of a subclass without affecting the correctness
    of the program. This means that a subclass should be a subtype of its superclass and that objects of the
    subclass should be able to be used wherever objects of the superclass are expected without introducing any
    new bugs or causing any existing functionality to break.

## Interface Segregation Principle (ISP)

    It states that a client should not be forced to depend on interfaces that it does not use.
    In other words, it is better to have multiple smaller interfaces that are tailored to specific
    needs rather than a single large interface that tries to cover everything.*/

## Dependency Inversion Principle (DIP)

    It states that high-level modules should not depend on low-level modules. Instead, both should
    depend on abstractions. This promotes loose coupling and flexibility, making it easier to make
    changes without affecting other parts of the system.